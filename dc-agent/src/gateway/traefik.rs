//! Traefik dynamic configuration file management.
//!
//! Traefik handles HTTPS via SNI-based TCP passthrough (VMs handle their own TLS).
//! HTTP (port 80) is redirected to HTTPS at the entrypoint level.
//! TCP/UDP port forwarding for other ports is handled by iptables DNAT (see iptables.rs).

use super::port_allocator::PortAllocation;
use anyhow::{Context, Result};
use std::path::PathBuf;

/// Manager for Traefik dynamic configuration files.
pub struct TraefikConfigManager {
    config_dir: PathBuf,
}

impl TraefikConfigManager {
    /// Create a new Traefik config manager.
    pub fn new(config_dir: &str) -> Self {
        Self {
            config_dir: PathBuf::from(config_dir),
        }
    }

    /// Generate the config file path for a VM.
    fn config_path(&self, slug: &str) -> PathBuf {
        self.config_dir.join(format!("vm-{}.yaml", slug))
    }

    /// Write Traefik configuration for a VM (HTTPS via SNI passthrough).
    /// VM handles its own TLS certificate. Other TCP/UDP ports handled by iptables DNAT.
    pub fn write_vm_config(
        &self,
        slug: &str,
        subdomain: &str,
        internal_ip: &str,
        allocation: &PortAllocation,
        contract_id: &str,
    ) -> Result<()> {
        let config = self.generate_config(slug, subdomain, internal_ip, allocation, contract_id);

        // Ensure directory exists
        std::fs::create_dir_all(&self.config_dir).with_context(|| {
            format!("Failed to create Traefik config dir {:?}", self.config_dir)
        })?;

        let path = self.config_path(slug);
        std::fs::write(&path, config)
            .with_context(|| format!("Failed to write Traefik config to {:?}", path))?;

        tracing::debug!("Wrote Traefik config: {:?}", path);
        Ok(())
    }

    /// Delete Traefik configuration for a VM.
    pub fn delete_vm_config(&self, slug: &str) -> Result<()> {
        let path = self.config_path(slug);
        if path.exists() {
            std::fs::remove_file(&path)
                .with_context(|| format!("Failed to delete Traefik config {:?}", path))?;
            tracing::debug!("Deleted Traefik config: {:?}", path);
        }
        Ok(())
    }

    /// Generate Traefik YAML configuration for a VM.
    /// Uses TCP passthrough with SNI routing - VM handles its own TLS.
    fn generate_config(
        &self,
        slug: &str,
        subdomain: &str,
        internal_ip: &str,
        allocation: &PortAllocation,
        contract_id: &str,
    ) -> String {
        let timestamp = chrono::Utc::now().to_rfc3339();

        format!(
            r#"# Generated by dc-agent for VM {slug}
# Contract: {contract_id}
# Created: {timestamp}
#
# HTTPS (443): SNI passthrough to VM:443 (VM handles TLS)
# TCP/UDP ports {base_port}-{end_port}: iptables DNAT

tcp:
  routers:
    {slug}-https:
      rule: "HostSNI(`{subdomain}`)"
      service: {slug}-https
      entryPoints:
        - websecure
      tls:
        passthrough: true

  services:
    {slug}-https:
      loadBalancer:
        servers:
          - address: "{internal_ip}:443"
"#,
            slug = slug,
            subdomain = subdomain,
            internal_ip = internal_ip,
            contract_id = contract_id,
            timestamp = timestamp,
            base_port = allocation.base,
            end_port = allocation.base + allocation.count - 1,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_generate_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TraefikConfigManager::new(temp_dir.path().to_str().unwrap());

        let allocation = PortAllocation {
            base: 20000,
            count: 10,
            contract_id: "contract-123".to_string(),
        };

        let config = manager.generate_config(
            "k7m2p4",
            "k7m2p4.dc-lk.decent-cloud.org",
            "10.0.1.5",
            &allocation,
            "contract-123",
        );

        // TCP passthrough routing with SNI
        assert!(config.contains("tcp:"));
        assert!(config.contains("HostSNI(`k7m2p4.dc-lk.decent-cloud.org`)"));
        assert!(config.contains("passthrough: true"));
        assert!(config.contains("address: \"10.0.1.5:443\""));
        assert!(config.contains("websecure"));

        // Contract info
        assert!(config.contains("contract-123"));

        // Port range mentioned in comments (handled by iptables)
        assert!(config.contains("20000-20009"));

        // Should NOT have HTTP routing or certResolver (VM handles TLS)
        assert!(!config.contains("http:"));
        assert!(!config.contains("certResolver"));
        assert!(!config.contains("letsencrypt"));
    }

    #[test]
    fn test_write_and_delete_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TraefikConfigManager::new(temp_dir.path().to_str().unwrap());

        let allocation = PortAllocation {
            base: 20000,
            count: 10,
            contract_id: "contract-123".to_string(),
        };

        manager
            .write_vm_config(
                "k7m2p4",
                "k7m2p4.dc-lk.decent-cloud.org",
                "10.0.1.5",
                &allocation,
                "contract-123",
            )
            .unwrap();

        let path = temp_dir.path().join("vm-k7m2p4.yaml");
        assert!(path.exists());

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("k7m2p4"));

        manager.delete_vm_config("k7m2p4").unwrap();
        assert!(!path.exists());
    }

    #[test]
    fn test_delete_nonexistent_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = TraefikConfigManager::new(temp_dir.path().to_str().unwrap());

        // Should not error when deleting non-existent file
        manager.delete_vm_config("nonexistent").unwrap();
    }
}
