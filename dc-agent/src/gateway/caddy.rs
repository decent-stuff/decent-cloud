//! Caddy per-VM configuration file management.
//!
//! A per-provider wildcard cert (*.{dc_id}.{gw_prefix}.{domain}) via DNS-01 with acme-dns
//! Each VM gets a handle block (imported inside the wildcard site block) that routes
//! traffic by hostname. TCP/UDP port forwarding is handled by iptables DNAT (see iptables.rs).

use super::port_allocator::PortAllocation;
use anyhow::{Context, Result};
use std::path::PathBuf;
use std::process::Command;

/// Manager for Caddy site configuration files.
pub struct CaddyConfigManager {
    sites_dir: PathBuf,
}

impl CaddyConfigManager {
    /// Create a new Caddy config manager.
    pub fn new(sites_dir: &str) -> Self {
        Self {
            sites_dir: PathBuf::from(sites_dir),
        }
    }

    /// Generate the config file path for a VM.
    fn config_path(&self, slug: &str) -> PathBuf {
        self.sites_dir.join(format!("{}.caddy", slug))
    }

    /// Write Caddy handle block for a VM (imported inside the wildcard site block).
    /// Routes traffic by hostname to VM:80 (plain HTTP). TCP/UDP ports handled by iptables DNAT.
    pub fn write_vm_config(
        &self,
        slug: &str,
        subdomain: &str,
        internal_ip: &str,
        allocation: &PortAllocation,
        contract_id: &str,
    ) -> Result<()> {
        let config = self.generate_config(slug, subdomain, internal_ip, allocation, contract_id);

        // Ensure directory exists
        std::fs::create_dir_all(&self.sites_dir)
            .with_context(|| format!("Failed to create Caddy sites dir {:?}", self.sites_dir))?;

        let path = self.config_path(slug);
        std::fs::write(&path, config)
            .with_context(|| format!("Failed to write Caddy config to {:?}", path))?;

        tracing::debug!("Wrote Caddy config: {:?}", path);

        // Reload Caddy to pick up the new config
        self.reload_caddy()?;

        Ok(())
    }

    /// Delete Caddy configuration for a VM.
    pub fn delete_vm_config(&self, slug: &str) -> Result<()> {
        let path = self.config_path(slug);
        if path.exists() {
            std::fs::remove_file(&path)
                .with_context(|| format!("Failed to delete Caddy config {:?}", path))?;
            tracing::debug!("Deleted Caddy config: {:?}", path);

            // Reload Caddy to remove the site
            self.reload_caddy()?;
        }
        Ok(())
    }

    /// Reload Caddy configuration.
    fn reload_caddy(&self) -> Result<()> {
        let output = Command::new("systemctl")
            .args(["reload", "caddy"])
            .output()
            .context("Failed to execute systemctl reload caddy")?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            tracing::warn!("Caddy reload returned non-zero: {}", stderr);
            // Don't fail - Caddy might not be running yet during initial setup
        }

        Ok(())
    }

    /// Generate Caddy handle block for a VM.
    /// Imported inside the wildcard site block; routes by hostname to VM:80.
    fn generate_config(
        &self,
        slug: &str,
        subdomain: &str,
        internal_ip: &str,
        allocation: &PortAllocation,
        contract_id: &str,
    ) -> String {
        let timestamp = chrono::Utc::now().to_rfc3339();

        format!(
            r#"# Generated by dc-agent for VM {slug}
# Contract: {contract_id}
# Created: {timestamp}
# TCP/UDP ports {base_port}-{end_port}: iptables DNAT

@{slug} host {subdomain}
handle @{slug} {{
    reverse_proxy {internal_ip}:80
}}
"#,
            slug = slug,
            subdomain = subdomain,
            internal_ip = internal_ip,
            contract_id = contract_id,
            timestamp = timestamp,
            base_port = allocation.base,
            end_port = allocation.base + allocation.count - 1,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_generate_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = CaddyConfigManager::new(temp_dir.path().to_str().unwrap());

        let allocation = PortAllocation {
            base: 20000,
            count: 10,
            contract_id: "contract-123".to_string(),
            internal_ip: Some("10.0.1.5".to_string()),
        };

        let config = manager.generate_config(
            "k7m2p4",
            "k7m2p4.dc-lk.decent-cloud.org",
            "10.0.1.5",
            &allocation,
            "contract-123",
        );

        // Named matcher inside wildcard site block
        assert!(config.contains("@k7m2p4 host k7m2p4.dc-lk.decent-cloud.org"));
        assert!(config.contains("reverse_proxy 10.0.1.5:80"));

        // Contract info
        assert!(config.contains("contract-123"));

        // Port range mentioned in comments (handled by iptables)
        assert!(config.contains("20000-20009"));
    }

    #[test]
    fn test_write_and_delete_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = CaddyConfigManager::new(temp_dir.path().to_str().unwrap());

        let allocation = PortAllocation {
            base: 20000,
            count: 10,
            contract_id: "contract-123".to_string(),
            internal_ip: Some("10.0.1.5".to_string()),
        };

        let config = manager.generate_config(
            "k7m2p4",
            "k7m2p4.dc-lk.decent-cloud.org",
            "10.0.1.5",
            &allocation,
            "contract-123",
        );

        // Write directly to test file operations
        std::fs::create_dir_all(&manager.sites_dir).unwrap();
        let path = manager.config_path("k7m2p4");
        std::fs::write(&path, &config).unwrap();

        assert!(path.exists());

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.contains("k7m2p4"));

        std::fs::remove_file(&path).unwrap();
        assert!(!path.exists());
    }

    #[test]
    fn test_delete_nonexistent_config() {
        let temp_dir = TempDir::new().unwrap();
        let manager = CaddyConfigManager::new(temp_dir.path().to_str().unwrap());

        // Create directory for delete to work
        std::fs::create_dir_all(&manager.sites_dir).unwrap();

        // Should not error when file doesn't exist (reload might fail but that's ok)
        let path = manager.config_path("nonexistent");
        assert!(!path.exists());
    }
}
