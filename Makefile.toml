[env]
RUST_BACKTRACE = "1"
SQLX_OFFLINE = "true"
# PostgreSQL defaults - compose postgres takes priority over .env
PG_PORT = { value = "5432", condition = { env_not_set = ["PG_PORT"] } }
PG_USER = { value = "test", condition = { env_not_set = ["PG_USER"] } }
PG_PASSWORD = { value = "test", condition = { env_not_set = ["PG_PASSWORD"] } }
PG_DB = { value = "test", condition = { env_not_set = ["PG_DB"] } }
# Compose postgres IP (dc-agent-1-postgres-1 container)
COMPOSE_PG_HOST = "172.18.0.2"

[config]
default_to_workspace = false
init_task = "postgres-start"
end_task = "cleanup"
on_error_task = "cleanup"
unstable_features = ["CTRL_C_HANDLING"]
load_script = '''
#!/usr/bin/env bash
# Load .env file if present
if [ -f .env ]; then
    set -a
    . .env
    set +a
fi
'''

[tasks.postgres-start]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail
source scripts/detect-postgres.sh

if [ "$PG_SOURCE" = "compose" ]; then
    echo "✓ Using compose PostgreSQL at ${PG_HOST}:${PG_PORT}"
    exit 0
fi

echo "Compose postgres not available, checking ${PG_HOST}:${PG_PORT}..."
for i in {1..30}; do
    if PGPASSWORD="${PG_PASSWORD}" psql -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" -d "${PG_DB}" -c "SELECT 1" >/dev/null 2>&1; then
        echo "✓ PostgreSQL ready at ${PG_HOST}:${PG_PORT}"
        exit 0
    fi
    echo "  waiting... ($i/30)"
    sleep 1
done
echo "✗ Failed to connect to PostgreSQL at ${PG_HOST}:${PG_PORT}" >&2
exit 1
'''

[tasks.dfx-start]
dependencies = ["postgres-start"]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

cd ic-canister
for i in {1..10}; do dfx stop && break; sleep 1; pkill -9 -f versions || true; done;
dfx start --background --clean
while true; do
    dfx ping local && break;
    sleep 1;
done;
dfx canister create --all
'''

[tasks.format]
dependencies = ["dfx-start"]
install_crate = "rustfmt"
command = "cargo"
args = ["fmt", "--", "--emit=files"]

[tasks.canister]
dependencies = ["dfx-start"]
command = "dfx"
args = ["build", "--all"]
cwd = "./ic-canister/"

[tasks.clippy]
dependencies = ["postgres-start", "sqlx-prepare", "dfx-start"]
command = "cargo"
args = ["clippy", "--workspace", "--tests"]

[tasks.clippy-canister]
dependencies = ["dfx-start"]
command = "cargo"
args = ["clippy", "--target=wasm32-unknown-unknown"]
cwd = "./ic-canister/"

[tasks.build]
dependencies = ["postgres-start", "sqlx-prepare", "dfx-start"]
command = "cargo"
args = ["build", "--workspace"]

# API-only tasks (no dfx/canister dependencies - for production builds)
[tasks.build-api]
dependencies = ["postgres-start", "sqlx-prepare"]
command = "cargo"
args = ["build", "-p", "api", "-p", "dc-agent", "-p", "decent-cloud"]

[tasks.clippy-api]
dependencies = ["postgres-start", "sqlx-prepare"]
command = "cargo"
args = ["clippy", "-p", "api", "-p", "dc-agent", "-p", "decent-cloud", "--tests"]

[tasks.test-api]
clear = true
dependencies = ["postgres-start", "sqlx-prepare", "build-api"]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail
source scripts/detect-postgres.sh
export TEST_DATABASE_URL="postgres://${PG_USER}:${PG_PASSWORD}@${PG_HOST}:${PG_PORT}/${PG_DB}"
cargo nextest run -p api -p dc-agent -p decent-cloud
'''

[tasks.setup-python]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

python3 scripts/setup-python-env.py
'''

[tasks.install-pocket-ic]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

python3 scripts/install-pocket-ic.py
'''

[tasks.build-whitepaper]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

if [ ! -d ".venv" ]; then
    echo "Virtual environment not found. Running setup first..."
    python3 scripts/setup-python-env.py
fi

source .venv/bin/activate
python3 ./docs/whitepaper/build.py
'''


[tasks.test]
clear = true
dependencies = [
    "postgres-start",
    "sqlx-prepare",
    "dfx-start",
    "build",
    "canister",
]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail
source scripts/detect-postgres.sh
export TEST_DATABASE_URL="postgres://${PG_USER}:${PG_PASSWORD}@${PG_HOST}:${PG_PORT}/${PG_DB}"
cargo nextest run --workspace
'''

[tasks.dfx-stop]
script = '''
#!/usr/bin/env bash
set -eExuo pipefail

( cd ./ic-canister && for i in {1..10}; do dfx stop && break; sleep 1; pkill -9 -f versions || true; done; )
'''

[tasks.postgres-stop]
script = '''
#!/usr/bin/env bash
# No-op: external postgres is not managed by this build
echo "✓ PostgreSQL (external) - nothing to stop"
'''

[tasks.sqlx-prepare]
dependencies = ["postgres-start"]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

unset SQLX_OFFLINE
source scripts/detect-postgres.sh
echo "Using PostgreSQL at ${PG_HOST}:${PG_PORT} (source: ${PG_SOURCE})"

# Helper to run psql
psql_exec() {
    PGPASSWORD="${PG_PASSWORD}" psql -h "${PG_HOST}" -p "${PG_PORT}" -U "${PG_USER}" -d "${PG_DB}" "$@"
}

# Generate unique temporary database name
TMP_DB_NAME="sqlx_prepare_$(date +%s)_$$"

cleanup() {
    local exit_code=$?
    echo "Cleaning up temporary database..."
    psql_exec -c "DROP DATABASE IF EXISTS ${TMP_DB_NAME};" 2>/dev/null || true
    exit ${exit_code}
}
trap cleanup EXIT INT TERM

# Create temporary database
echo "Creating temporary database: ${TMP_DB_NAME}"
if ! psql_exec -c "CREATE DATABASE ${TMP_DB_NAME};" >/dev/null 2>&1; then
    echo "✗ Failed to create temporary database" >&2
    exit 1
fi

# Set DATABASE_URL for sqlx
export DATABASE_URL="postgresql://${PG_USER}:${PG_PASSWORD}@${PG_HOST}:${PG_PORT}/${TMP_DB_NAME}"

# Run migrations
echo "Running migrations..."
if ! sqlx migrate run --source api/migrations_pg; then
    echo "✗ Migration failed" >&2
    exit 1
fi

# Prepare sqlx data
echo "Preparing sqlx data..."
if ! cargo sqlx prepare --workspace -- --tests; then
    echo "✗ sqlx prepare failed" >&2
    exit 1
fi
echo "✓ sqlx prepare completed"
'''

[tasks.website-check]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

cd website
OUTPUT=$(npm run check 2>&1)
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo "$OUTPUT"
    exit $RESULT
fi
'''

[tasks.website-build]
dependencies = ["website-check"]
script = '''
#!/usr/bin/env bash
set -eEuo pipefail

cd website
OUTPUT=$(npm run build 2>&1)
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo "$OUTPUT"
    exit $RESULT
fi
'''

[tasks.all]
dependencies = [
    "format",
    "dfx-start",
    "canister",
    "clippy",
    "clippy-canister",
    "build",
    "test",
    "website-check",
    "website-build",
    "dfx-stop",
]

# API-only full check (no dfx/canister - for CI/production)
[tasks.all-api]
dependencies = [
    "clippy-api",
    "build-api",
    "test-api",
]

[tasks.cleanup]
dependencies = ["dfx-stop", "postgres-stop"]
